# NOTE

## 关于移动零的思考

数组支持随机访问，其时间复杂度为 O(1)，因此解决移动零最好的方式就是使用索引来替换位置。同样的方法在 Java 中执行用时为 0 ms 的方法，在 PHP 中却需要 20 ms，go 中则需要 92 ms。在 PHP 中， array 虽然被叫做数组，但实际上其底层的实现却是哈希表（Hash Table）。
而 Go 语言中的数组是值类型，一个数组变量就表示着整个数组，意味着 Go 语言的数组在传递的时候，传递的是原数组的拷贝。

## 关于爬楼梯的思考

拿到题目的时候第一时间会在脑海里面找排列组合的公式，未果，准备暴力解时发现一直循环很变态。看题解时很出乎意料，这怎么就联想到斐波那契数列呢？

## 关于三数之和的思考

仍旧是第一时间想到暴力解，而这道题的暴力解法也是很麻烦，还要避免重复等等。然而大费周章写出来之后却一直执行超时，头发都快掉光仍旧没有想到不超时的方法，看题解时发现其实可以优先考虑边界场景，如此一来可以节省很多不必要的重复，另外可以在已知 `x = -(y+z)` 的情况下，优先排序来查找 y 和 z 的值，这里既可以避免多一次循环，还能继续考虑边界场景进行优化。

## 关于删除排序数组中的重复项

不知道这道题的存在意义是什么？题解中很多解法只适用于已经「排序」好的数组，也并没有真正的删除数组中的元素。

## 关于环形链表的思考

此前听过老师讲解这道题，想着一展拳脚之时，发现居然没有 PHP 可以施展的空间。无奈之下只好用 go 完成，同时也很好奇为什么 PHP 没有解题的空间，于是乎试着用 PHP 写出这道题的测试用例，然后再解决它。

## 关于反转链表II的思考

链表类的题，LeetCode 国际站上别说 discuss 了，居然连个提交都没有。。。。。。很强烈地感受到我大 PHP 要亡。链表题的难点在于指针的指向，看懂链表的结构并不是很难，但是一旦把它和指针混在一起，就很容易让人摸不着头脑。而 PHP 的日常开发里，是没有指针这个概念的。将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。在编写链表代码的时候，我们经常会有这样的代码：p->next=q。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。还有一个更复杂的，也是我们写链表代码经常会用到的：p->next=p->next->next。这行代码表示，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址。

## 关于两两交换链表中的节点思考
每次用递归就觉得自己是个傻子。即便有老师讲的递归模板，处理过程看题解也是很难理解的，特别是当递归遇上指针，想死的心都有了。总结一下检查链表代码是否正确的边界条件：

1. 链表为空时
2. 链表只包含一个节点时
3. 链表只包含两个节点时
4. 代码逻辑在处理头结点和尾节点的时候

必须熟练的五个链表代码：
* 单链表反转
* 链表中环的检测
* 两个有序的链表合并
* 删除链表倒数第 n 个节点
* 求链表的中间节点

