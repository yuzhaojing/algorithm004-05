# NOTE

本周的知识点都是一些很基础的数据结构，数组，链表，跳表，栈，队列，双端队列，优先队列。

### 数组

数组是很老生常谈的数据结构了，基本是大家所学的第一种数据结构。其特点就是支持 `O(1)` 的随机访问，但是由于其地址和下标的连贯性，所以当插入和删除元素时就需要挪动指定位置后面的所有元素，复杂度就上升到了 `O(n)`。

关于数组的算法题，基本就是双指针法了，左右两个指针向中间夹逼。当然有时候需要对数组做一些额外的操作，比如在 [3sum](https://leetcode.com/problems/3sum/) 这道题中就需要先对数组做一个排序。

### 链表

与数组相反，链表是依靠节点中的指针来做前后节点的关联的，事实上相邻的两个节点在内存中的地址并不一定是相连的，因此当你想在链表中寻找指定的元素时只能从头开始遍历，一个一个比较，复杂度就是 `O(n)`，但是一旦确定了元素的位置，插入和删除操作只需要移动前后两个节点的指针即可，所以复杂度是 `O(1)`。

关于链表的算法题，感觉没什么技巧，但是有时候加上一个临时的头节点或尾节点（标兵）会比较方便处理问题，唯一要注意的就是操作指针的顺序，一旦顺序错乱就容易出现环，需格外注意。

针对有环的链表用快慢指针法来做也是极为巧妙。

### 跳表

针对链表查询 `O(n)` 的时间复杂度，跳表做了升级。从一维链表中每隔一个节点就抽出一个节点来组成一个索引，当然如果索引太大，还可以针对索引再做二级索引...

故跳表的查询时间复杂度为 `O(logn)`。

当然，因为有了索引的存在，当要插入和删除节点时还需要同时更新下索引。这就增加了复杂度。

### 栈

可以把栈想象为一个桶，只能从上面放入和取出数据，（LIFO）后进先出。这种结构比较适合处理「最近相关性」的题目。浏览器的前进后退也都可以基于此实现。

基于数组或者链表都可以实现栈，但是由于栈只在队尾进行操作，所以大都是基于数组来实现，唯一的缺点就是扩从数组容量时的数据的拷贝花销。

### 队列

与栈不同，队列时讲究公平性的，一端只可以入队，另一端只可以出队，可以把队列想象成为一个管道，数据在管道里面单向流动，（FIFO）先进先出。因为其支持在两端都为 O(1) 复杂度的操作，所以队列大都是基于链表实现的。当然也有基于数组的队列。

### 双端队列

双端队列在队列的基础上做了完善，在队列两端都支持入队和出队操作。

### 优先队列

优先队列类似于单向队列，唯一的区别就是其不再是 FIFO，而是基于元素的优先级来排序，优先级较高者先出队，所以就要求放入队列中的元素支持优先级大小的比较。

## 总结

刷题要多过遍数，同是要多看社区排名靠前的解法，师夷长技以制夷，将别人优秀的思想学以致用。另外一个点就是要懂得**空间换时间**。


### 改写 Deque 代码

```java
Deque<String> deque = new LinkedList<String>();
deque.addFirst("a"); 
deque.addFirst("b");
deque.addFirst("c");

System.out.println(deque);
String str = deque.peek();
System.out.println(str);
System.out.println(deque);

while (deque.size() > 0) {
		System.out.println(deque.pop()); 
}

System.out.println(deque);
```