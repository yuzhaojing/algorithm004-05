# NOTE

  这周学习了HashMap，映射，集合,树，二叉树，递归，回溯，分治等相关知识
  HashMap是通过哈希函数将key值计算为数值，以数值为索引记录位置，如果两个key值计算的数值一样，此索引对应的数据结构转换为链表，甚至树 这种情况叫哈希碰撞
  java中的set是接口类，定义了一系列的规则
  常用方法：
    add( )         向集合中添加元素
    clear( )        去掉集合中所有的元素
    contains( )    判断集合中是否包含某一个元素
    isEmpty( )    判断集合是否为空
    iterator( )    主要用于递归集合，返回一个Iterator()对象
    remove( )    从集合中去掉特定的对象
    size( )        返回集合的大小
   
树：树是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null或empty)树。一棵非空的树包括一个根结点，还(很可能)    有多个附加结点，所有结点构成一个多级分层结构。
二叉树：根节点只有左右两个节点或者子树的数据结构
其中左节点小于根节点，右节点大于根节点，以此类推的树为二叉搜索树，因为其固定的规则，此类树以中序遍历查询会返回一个升序数组，这样会提升搜索消耗的时间
递归：自己调用自己
核心思想就是寻找最小的重复性
递归代码模板
public void recur(int level, int param) { 

  // terminator 跳出递归的条件避免死循环
  if (level > MAX_LEVEL) { 
    // process result 
    return; 
  } 

  // process current logic 处理本层业务逻辑
  process(level, param); 

  // drill down 重复调用自己 进入下一层 同时改变参数值 
  recur( level: level + 1, newParam); 

  // restore current status 清理当前层数据 
 
}

分治：
将逐级递归分解，类似多线程处理的逻辑或者是二分法处理的逻辑来降低逐级递归的时间复杂度
回溯：
在某些情况下根据结果值会推结果看与条件是否冲突，如果冲突结果不正确，常用于类似N皇后问题
