## 知识点概要

本周学习的内容主要有哈希表，树，二叉树，二叉搜索树，递归，分治以及回溯。

### 哈希表
哈希表底层基本是基于数组和链表来实现的，数组可以通过下标快速定位位置，而链表则可以解决当元素通过 Hash 函数得到的下标冲突的问题。

[HashMap 源代码分析](https://coderlmm.github.io/2018/02/27/what-is-HashMap/) 是自己之前写的关于 HashMap 的源码分析，文章较长，就不贴这里了，有兴趣的进链接去看吧。

我单独把 JDK 1.8 中的 HashMap 几个设计的非常巧妙的地方粘过来。

1. tableSizeFor 函数设计的很赞，利用移位操作来获取大于等于 cap 的 最小的 2 的幂。
1. 把哈希桶的大小设计为 2 的 幂，用位运算代替取模来确定索引位置。
1. 把哈希桶的大小设计为 2 的 幂，扩容是不需要重新计算元素的 hash 值。只需要看元素 e.hash & oldCap 的值是 0 还是 1 即可。而且可以认为这个值是随机的。
1. hash 函数加入 key 的高位加入运算。使得 hash 值更均匀。

### 树 & 递归

链表是特殊化的树，而树是特殊化的图。因为树的结构的特殊化，所以关于树的操作基本都是用递归来实现，而递归正是自己比较薄弱的地方，通过老师讲解的生成括号问题以及给出的递归弟代码模版，现在基本上看到一个递归考点的题都会与生成括号问题做类比，发现自己慢慢的好像也掌握了些思路，再多加练习，相信会越来越熟练。

树是一种比较高级的数据结构，有着及其广泛的应用，比如 MySQL 数据库中数据的存放都是基于树来实现的，所以有必要把树学好。

树的遍历分为深度优先遍历和广度优先遍历，广度优先遍历就是按层来遍历，靠近节点的元素先被输出。而深度优先遍历又分为前序（根左右），中序（左根右）和后序（左右根），也就是前中后的关键点是看根节点的顺序。

二叉搜索树的中序遍历是有序的。此特性可以用来验证一个树是否是二叉树。

### 分治 & 回溯

分治和回溯是建立在递归的基础上，分治是将大问题分解成几个小的问题，然后在将小问题分解成更小的问题，直到问题无法分解为止，然后将小问题的答案一个个合并起来即可。而回溯类似于不断的的试错，可行的话就一直向下递归，如果不可行就退回上一步，此时基本都要清除上一层的状态，然后再继续。


## Review 其他同学作业

170 号同学的总结很认真，记录了本周的重点，同时还记下了老师给出的递归模版。看他总结的同时自己又复习了一遍。

150 号同学分析 HashMap 的总结很详细，看的出来是自己认真看了代码的，但有一点就是没有指出该 HashMap 所在的 JDK 的版本号，而文末反馈出来的问题只会在特定的版本中才会出现。不够严谨。

755 号同学的总结是英文的，惊了个呆，班级里面真是卧虎藏龙啊。

295 号同学总结了递归和回溯的模版以及常用思路，还有自己对 HashMap 的理解，最后关于 HashMap 树化来提高安全性是自己之前没有想到的。

445 号同学总结的 HashMap 源码加了很多自己的注释，很棒，只是总结格式可以稍作调整，这样的话可读性会比较强。