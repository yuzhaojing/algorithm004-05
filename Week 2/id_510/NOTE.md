# NOTE 第二周

int i=1;
i = i++;  后面的i先赋值给前面的i，然后后面的i再++，那么最终的i==1;
i = ++i;  后面的i先++等于2，然后赋值给i 则最终i==2；

if(i-- > 0) 返回true；
if(--i > 0) 返回false；

哨兵

hash 
   比较是否相同时可借助hash值比较
   利用点位计数排序


tree（遍历）

二叉树遍历  左边一路拉到底，然后开始处理右边
    
递归   前序   从左向右   打印    递归左边  递归右边
      中序   从左向右   递归左边 打印     递归右边
      后序   从左向右   递归左边 递归右边  打印
      层序   从左到右   层标识 子节点从左向右遍历


栈    前序  不为空  打印->入栈->左边         为空 出栈->右边           打左右
      中序  不为空  入栈->左边              为空 出栈->打印->右边      左右打
      后序  不为空 加入链表头部->入栈->右边   为空  出栈->左边          链表入头右左
      层序  队列实现 不为空 计数队列大小count，子循环遍历队列count次，从左到右将子节点加入队列



recursion


divide-conquer