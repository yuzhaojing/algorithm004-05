# NOTE

广度优先遍历和深度优先遍历。
  
  对于二叉树的遍历存在：
  前序遍历：中左右
  中序遍历：左中右
  后序遍历：左右中
  前/中/后，代表什么时候遍历根节点。但是无论什么情况，都是先遍历左，才到右
  
  对于N叉树的遍历存在：深度优先遍历和广度优先遍历
  深度：
    数据结构：栈
    从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点为止。 
    最简单就是递归，因为系统自动帮我们维护了一个栈。
    
  广度：
    数据结构：队列
    从根节点出发，在横向遍历二叉树层段节点的基础上纵向遍历二叉树的层次。
    
贪心算法
  假设一个问题比较复杂，那么我们可以考虑把原问题拆成几个小问题，分别求每个小问题的最优解，再把这些“局部最优解”叠起来，就“当作”整个问题的最优解。
  第一步
    明确到底什么是最优解。
  第二步
    明确什么是子问题的最优解。（只有当大问题能拆解成同类型的子问题时，才能使用贪心算法）
  第三步
    分别求出子问题的最优解再堆叠出全局最优解。
    
    贪心算法与动态规划不同，一旦做出了选择，那么就不能在改变了。动态规划还可以回到上一步进行改变。
    
二分查找   

  使用条件：必须采用顺序存储结构，而且表中元素按关键字有序排列

  代码思路：
  1、将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；
  2、获取中间值，如果中间位的值大于查找的值，则查找中间值前的数据，否则查找中间值后的数据；
  3、重复以上过程，直到找到满足条件的值或无该值。return。
  
  二分查找可以应用的其他场景是：
    大于中间值或者小于中间值，只是某个判断条件，我们可以改用，如果满足xxx条件，则往前查找，如果满足xxx条件则往后。
    但是，我们依然要保证，该表数据，一定在某个条件下是有序的。

  
