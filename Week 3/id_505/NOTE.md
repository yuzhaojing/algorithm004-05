# 505-WEEK03

  

### 学习总结
本周学习了 `DFS` 、 `BFS` 、贪心和二分查找。

#### DFS && BFS

DFS 由于本身是栈的方式的进行访问，也可以通过递归代替栈来实现，递归过程本身就是栈的形式，因此两者可以天然互换。由于访问的都是栈顶的元素，在访问树，图时，每次都是访问节点的展开下一级的节点，也可以想象为叶子的叶子节点，因此优先向下搜索，因此称为深度优先遍历。

BFS 之前学之前用队列实现过，但是没有想明白用递归写。现在看来，完全没有必要用递归来写。因为它和 DFS 的访问是不同的。访问完一层再访问下一层，使用队列后，每次出队的和前一个节点是同一级节点（在临近上下级界限前），并将当前节点的下一级节点入队。BFS 的层数可以作为很多答案的最小次数。

#### 贪心

接触贪心算法前，一直认为贪心算法是一种难度很高，择优选择的固定算法，经过老师的讲解后原来贪心的难度不在于算法本省，而是一种数学思维的推导。用于贪心可以解决的问题会有比较明显的特征。可以用数学来证明选择每次迭代的最优结果，最后就是最优解。因此贪心并不是一种解法，而是一种结题思路，由于本身思路就有一定的局限性，因此在解决问题上并不广泛。可能在结题时局部部分可以进行贪心。

#### 二分查找

以 [153](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/submissions/) 题为例子，二分查找的前提是深度，有界，可以下标索引。随后旋转后的数组不再是按升序来排列，但是我们二分后仍然有界。画图示例：

![](http://pic.izixia.cn/FsIlgFJDnnDjflcJygs3VQgApR9q)

可以清晰看到最小点的位置随中点的变化，如果在左边升序部分，最小值在其右边，如果在右边升序部分，最小值在其左边。因此二分的条件就可以找到了。

```java
if (nums[mid] < nums[AR]) {
      //在左边
     AR = mid;
 } else if (nums[mid] > nums[AL]) {
      //在右边
     AL = mid + 1;
 }
```



完整代码可以查看[这里](https://github.com/KeithMorning/algorithm004-05/blob/master/Week%203/id_505/153.find-minimum-in-rotated-sorted-array.java)。